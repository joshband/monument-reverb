# Monument Brutalist Asset Integration Plan

**Date:** 2026-01-05
**Status:** Ready for Implementation
**Assets Location:** `assets/ui/panels/` and `assets/ui/components/`

## Overview

This document outlines the integration plan for Monument Brutalist assets generated by the Materialize pipeline. These assets provide photorealistic concrete panels with baked knob shadows and PBR-enabled UI components.

---

## Assets Inventory

### Background Panels (4 sections)
Located in: `assets/ui/panels/`

| File | Dimensions | Size | Usage | Shadow Count |
|------|------------|------|-------|--------------|
| `macro_cosmos_panel.png` | 900×240px | 304KB | Macro controls section | 10 knob shadows |
| `foundation_panel.png` | 900×200px | 200KB | Base parameters | 12 knob shadows |
| `modulation_panel.png` | 900×150px | 197KB | Modulation section | None (smooth) |
| `temporal_panel.png` | 900×180px | 218KB | Timeline section | None (textured) |

### UI Components (3 types)
Located in: `assets/ui/components/`

| Component | States | PBR Maps | Size | Notes |
|-----------|--------|----------|------|-------|
| `rotary_knob_midcentury_v0.1` | default | Full PBR suite | ~80MB | Brutalist concrete knob |
| `led_push_button_midcentury_v0.1` | on/off | Albedo + emissive | ~40MB | Toggle with glow effect |
| `vertical_slider_midcentury_v0.1` | neutral | Track + handle | ~35MB | Full-height slider |

**PBR Maps Available:**
- `albedo.png` - Base color/texture
- `normal.png` - Surface details
- `roughness.png` - Surface finish
- `metallic.png` - Metallic properties
- `height.png` - Displacement data
- `orm.png` - Packed ORM map (Occlusion/Roughness/Metallic)
- `composite.png` - Pre-composited RGBA (ready for direct use)

---

## Integration Strategy

### Phase 1: Background Panel Integration ✅ Ready

**Current Implementation:**
- `StoneBackgroundComponent` (procedural texture)
- Dark grey gradient with noise texture
- Panel dividers with embossed effect

**Migration Plan:**
1. Replace `StoneBackgroundComponent::paint()` with image-based rendering
2. Load 4 panel PNGs based on section positions
3. Position images according to current layout dividers
4. Maintain existing divider API for dynamic layouts

**Implementation:**

```cpp
// StoneBackgroundComponent.h
class StoneBackgroundComponent : public juce::Component
{
public:
    // ... existing methods ...

    // NEW: Load Monument Brutalist panels
    void loadBrutalistPanels();

private:
    // NEW: Panel images
    juce::Image macroPanelImage;      // 900×240px - top section
    juce::Image foundationPanelImage; // 900×200px - base params
    juce:Image modulationPanelImage;  // 900×150px - modulation
    juce::Image temporalPanelImage;   // 900×180px - timeline

    // Option: Use PBR shaders for enhanced rendering
    bool usePBRRendering = false;
};
```

```cpp
// StoneBackgroundComponent.cpp
void StoneBackgroundComponent::loadBrutalistPanels()
{
    auto assetsDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile)
        .getChildFile("Contents/Resources/assets/ui/panels");

    macroPanelImage = juce::ImageCache::getFromFile(assetsDir.getChildFile("macro_cosmos_panel.png"));
    foundationPanelImage = juce::ImageCache::getFromFile(assetsDir.getChildFile("foundation_panel.png"));
    modulationPanelImage = juce::ImageCache::getFromFile(assetsDir.getChildFile("modulation_panel.png"));
    temporalPanelImage = juce::ImageCache::getFromFile(assetsDir.getChildFile("temporal_panel.png"));

    repaint();
}

void StoneBackgroundComponent::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds();

    // Render background panels
    if (macroPanelImage.isValid())
    {
        // Macro section (top)
        auto macroArea = bounds.removeFromTop(240);
        g.drawImage(macroPanelImage, macroArea.toFloat(),
                   juce::RectanglePlacement::stretchToFit);
    }

    if (foundationPanelImage.isValid())
    {
        // Foundation section (base params)
        auto foundationArea = bounds.removeFromTop(200);
        g.drawImage(foundationPanelImage, foundationArea.toFloat(),
                   juce::RectanglePlacement::stretchToFit);
    }

    // ... render remaining sections ...
}
```

**Benefits:**
- ✅ Authentic brutalist concrete texture
- ✅ Baked knob shadows for realistic lighting
- ✅ Tonal variation per section (macro = dark, foundation = medium, etc.)
- ✅ GPU-accelerated image rendering (faster than procedural)

---

### Phase 2: Rotary Knob Component Integration

**Current Implementation:**
- `PhotorealisticKnob` (filmstrip-based, 128 frames)
- Stone texture with blue LED center
- 1024×1024px per frame (131MB total per variant)

**Monument Brutalist Knob Specs:**
- Concrete material with tactile indicator
- PBR materials: albedo, normal, orm, height
- Composite PNG available for direct use
- Size: ~80MB per component

**Option A: Use Composite PNG (Quick Integration)**

Simplest approach - use `composite.png` as a static knob image.

```cpp
// PhotorealisticKnob.cpp - Add new style enum
enum class Style
{
    // ... existing styles ...
    BrutalistConcrete,  // NEW: Monument Brutalist knob
};

juce::Image PhotorealisticKnob::loadFilmstripForStyle(Style style)
{
    if (style == Style::BrutalistConcrete)
    {
        // Load single composite image (not filmstrip)
        auto assetsDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile)
            .getChildFile("Contents/Resources/assets/ui/components/rotary_knob_midcentury_v0.1/default");

        return juce::ImageCache::getFromFile(assetsDir.getChildFile("composite.png"));
    }

    // ... existing filmstrip loading ...
}
```

**Pros:**
- Quick to implement
- Uses pre-composited RGBA (ready to render)
- No additional tooling required

**Cons:**
- Static image (no rotation animation)
- No PBR lighting response
- Loses filmstrip smoothness

**Option B: Generate Filmstrip from PBR Materials (Advanced)**

Render 128 frames using PBR materials + rotation.

```bash
# Use Blender to generate filmstrip
cd ~/Documents/3_Development/Repos/materialize/component_generation
python3 generate_filmstrip_from_pbr.py \
  --component rotary_knob_midcentury_v0.1 \
  --frames 128 \
  --size 1024 \
  --rotation-range "-135:135" \
  --output ~/Documents/3_Development/Repos/monument-reverb/assets/ui/knobs_brutalist/
```

**Pros:**
- Smooth rotation animation (128 frames)
- PBR lighting baked into filmstrip
- Compatible with existing `PhotorealisticKnob` code

**Cons:**
- Requires additional tooling/scripts
- Large file size (~130MB per knob variant)
- Pre-rendering time (~10-15 minutes)

**Recommendation:** Start with **Option A** for quick integration, then upgrade to **Option B** if rotation animation is critical.

---

### Phase 3: LED Push Button Integration

**Monument Brutalist Button Specs:**
- Two states: `on/` and `off/`
- Each state has composite PNG
- Emissive layer for LED glow effect

**Current JUCE Implementation:**
- `MonumentToggle` (custom toggle button)
- No PBR support currently

**Integration Approach:**

```cpp
// MonumentToggle.h - Add brutalist style
class MonumentToggle : public juce::Component
{
public:
    enum class Style
    {
        Classic,         // Existing style
        BrutalistLED     // NEW: Monument Brutalist LED button
    };

    MonumentToggle(juce::AudioProcessorValueTreeState& state,
                   const juce::String& parameterId,
                   const juce::String& labelText,
                   Style style = Style::Classic);

private:
    void loadBrutalistImages();

    juce::Image brutalistOffImage;
    juce::Image brutalistOnImage;
    Style currentStyle;
};
```

```cpp
// MonumentToggle.cpp
void MonumentToggle::loadBrutalistImages()
{
    auto assetsDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile)
        .getChildFile("Contents/Resources/assets/ui/components/led_push_button_midcentury_v0.1");

    brutalistOffImage = juce::ImageCache::getFromFile(
        assetsDir.getChildFile("off/composite.png"));
    brutalistOnImage = juce::ImageCache::getFromFile(
        assetsDir.getChildFile("on/composite.png"));
}

void MonumentToggle::paint(juce::Graphics& g)
{
    if (currentStyle == Style::BrutalistLED)
    {
        auto& image = button.getToggleState() ? brutalistOnImage : brutalistOffImage;
        g.drawImage(image, getLocalBounds().toFloat());
    }
    else
    {
        // Existing classic style rendering
    }
}
```

**Emissive Glow Effect:**

The `on/` state has an emissive layer for LED glow. JUCE doesn't natively support emissive materials, but we can approximate:

```cpp
void MonumentToggle::paintEmissiveGlow(juce::Graphics& g)
{
    if (!button.getToggleState())
        return;

    // Load emissive map from materials/emissive.png
    auto emissiveMap = loadEmissiveMap();

    // Render with additive blend mode
    g.setOpacity(0.7f);
    g.drawImage(emissiveMap, getLocalBounds().toFloat(),
               juce::RectanglePlacement::centred);
}
```

**Advanced Option:** Use OpenGL shader for real-time emissive rendering:

```glsl
// Fragment shader for LED glow
uniform sampler2D albedoMap;
uniform sampler2D emissiveMap;
uniform float glowIntensity;

void main()
{
    vec4 albedo = texture(albedoMap, texCoord);
    vec4 emissive = texture(emissiveMap, texCoord);

    // Additive glow
    vec3 finalColor = albedo.rgb + (emissive.rgb * glowIntensity);
    gl_FragColor = vec4(finalColor, albedo.a);
}
```

---

### Phase 4: Vertical Slider Integration

**Monument Brutalist Slider Specs:**
- Track + handle components
- 2 material layers
- Full-height design (fill ratio 1.0)

**Current Implementation:**
- No vertical slider component yet
- Would need to create new component

**Integration Approach:**

```cpp
// MonumentSlider.h - NEW component
class MonumentSlider : public juce::Component
{
public:
    enum class Orientation { Horizontal, Vertical };
    enum class Style { Classic, BrutalistConcrete };

    MonumentSlider(juce::AudioProcessorValueTreeState& state,
                   const juce::String& parameterId,
                   Orientation orientation = Orientation::Vertical,
                   Style style = Style::Classic);

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    void loadBrutalistImages();

    juce::Image trackImage;
    juce::Image handleImage;

    juce::Slider slider;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> attachment;
};
```

```cpp
// MonumentSlider.cpp
void MonumentSlider::loadBrutalistImages()
{
    auto assetsDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile)
        .getChildFile("Contents/Resources/assets/ui/components/vertical_slider_midcentury_v0.1/neutral");

    // Load track and handle separately for dynamic positioning
    trackImage = juce::ImageCache::getFromFile(assetsDir.getChildFile("materials/track/composite.png"));
    handleImage = juce::ImageCache::getFromFile(assetsDir.getChildFile("materials/handle/composite.png"));
}

void MonumentSlider::paint(juce::Graphics& g)
{
    // Draw track (fixed position)
    g.drawImage(trackImage, getLocalBounds().toFloat());

    // Draw handle (position based on slider value)
    auto handleY = calculateHandlePosition(slider.getValue());
    auto handleBounds = juce::Rectangle<int>(0, handleY, getWidth(), 50);
    g.drawImage(handleImage, handleBounds.toFloat());
}
```

---

## Implementation Roadmap

### Sprint 1: Background Panels (1-2 hours)
- [ ] Update `StoneBackgroundComponent` to load panel images
- [ ] Replace `paint()` method with image rendering
- [ ] Test panel positioning with dynamic layout
- [ ] Verify performance (GPU-accelerated rendering)

**Files to modify:**
- [StoneBackgroundComponent.h](ui/StoneBackgroundComponent.h)
- [StoneBackgroundComponent.cpp](ui/StoneBackgroundComponent.cpp)

### Sprint 2: Rotary Knob Integration (2-3 hours)
- [ ] Add `BrutalistConcrete` style to `PhotorealisticKnob::Style`
- [ ] Implement `loadBrutalistKnobImage()` method
- [ ] Update `paint()` to handle static image rendering
- [ ] Test with existing knob parameters
- [ ] **Optional:** Generate filmstrip for smooth rotation

**Files to modify:**
- [PhotorealisticKnob.h](ui/PhotorealisticKnob.h)
- [PhotorealisticKnob.cpp](ui/PhotorealisticKnob.cpp)

### Sprint 3: LED Button Integration (1-2 hours)
- [ ] Add `BrutalistLED` style to `MonumentToggle`
- [ ] Load on/off composite images
- [ ] Implement state-based image switching
- [ ] **Optional:** Add emissive glow effect

**Files to modify:**
- [MonumentToggle.h](ui/MonumentToggle.h)
- [MonumentToggle.cpp](ui/MonumentToggle.cpp)

### Sprint 4: Vertical Slider (2-3 hours)
- [ ] Create new `MonumentSlider` component
- [ ] Load track and handle images
- [ ] Implement slider value → handle position mapping
- [ ] Add to plugin editor layout
- [ ] Test parameter binding

**Files to create:**
- `ui/MonumentSlider.h`
- `ui/MonumentSlider.cpp`

### Sprint 5: Visual Polish & Testing (1-2 hours)
- [ ] Test all components in DAW (Logic Pro, Ableton, etc.)
- [ ] Verify PBR lighting consistency
- [ ] Check shadow alignment on panels
- [ ] Performance profiling (GPU usage, memory)
- [ ] Screenshot documentation

---

## Technical Considerations

### Asset Loading Strategy

**Option A: Bundle in Resources (Recommended for MVP)**
- Embed PNGs in app bundle (`Contents/Resources/assets/`)
- Fast loading (cached by OS)
- No external dependencies
- ~200MB increase in app size

**Option B: External Asset Pack**
- Load from user documents folder
- Smaller app bundle
- Requires asset installation step
- Flexible for future updates

**Recommendation:** Use **Option A** for initial release, migrate to **Option B** if bundle size becomes an issue.

### PBR Rendering Options

**Option 1: Pre-Composited RGBA (Current Approach)**
- Use `composite.png` directly
- Simple JUCE `Graphics::drawImage()`
- No shader complexity
- **Limitation:** Static lighting, no real-time PBR

**Option 2: Real-Time PBR Shader**
- Load albedo, normal, orm, height maps
- Implement PBR shader (OpenGL/Metal)
- Dynamic lighting response
- **Complexity:** Requires shader pipeline, more dev time

**Recommendation:** Start with **Option 1** (pre-composited) for quick integration. Evaluate **Option 2** if real-time lighting is critical for the aesthetic.

### Performance Benchmarks

**Expected Performance:**
- Panel image rendering: <1ms per frame (GPU-accelerated)
- Knob composite rendering: <0.5ms per knob
- LED button state switch: <0.1ms
- Total UI overhead: ~5-10ms per frame (well within 60fps budget)

**Memory Usage:**
- 4 panels: ~1MB total (compressed in ImageCache)
- 10 knobs: ~8MB (composite images)
- 2 buttons: ~1MB
- **Total:** ~10MB for all Monument Brutalist assets

---

## Testing Checklist

### Visual Testing
- [ ] Panel textures render at correct positions
- [ ] Knob shadows align with baked panel shadows
- [ ] LED button glow effect is visible and smooth
- [ ] Slider handle moves correctly along track
- [ ] No visual artifacts or seams

### Functional Testing
- [ ] All knobs respond to parameter changes
- [ ] Buttons toggle on/off correctly
- [ ] Sliders map values accurately
- [ ] Component state persists across preset changes
- [ ] Undo/redo works correctly

### Performance Testing
- [ ] UI renders at 60fps (16.67ms frame budget)
- [ ] No memory leaks (run overnight test)
- [ ] CPU usage stays below 5% when idle
- [ ] GPU acceleration is active (verify in Activity Monitor)

### Cross-Platform Testing
- [ ] macOS (Metal backend)
- [ ] Windows (DirectX backend) - if applicable
- [ ] Retina/HiDPI display scaling
- [ ] Light/dark mode compatibility

---

## Rollback Plan

If integration issues occur, revert changes:

```bash
cd ~/Documents/3_Development/Repos/monument-reverb

# Revert to previous commit
git checkout HEAD~1 -- ui/StoneBackgroundComponent.*
git checkout HEAD~1 -- ui/PhotorealisticKnob.*
git checkout HEAD~1 -- ui/MonumentToggle.*

# Rebuild
./scripts/build_macos.sh
```

**Backup Strategy:**
- Create git branch `feature/monument-brutalist-integration` before starting
- Commit after each sprint phase
- Tag stable versions: `v0.5-brutalist-panels`, `v0.6-brutalist-knobs`, etc.

---

## Next Steps

1. **Review this plan** with project stakeholders
2. **Create git branch** for integration work
3. **Start Sprint 1** (Background Panels)
4. **Iterate and test** each phase independently
5. **Document visual results** with screenshots/videos
6. **Prepare release notes** for Monument Brutalist UI update

---

## References

- **Asset Generation:** [component_generation/build/MONUMENT_COMPLETE.md](/Users/noisebox/Documents/3_Development/Repos/materialize/component_generation/build/MONUMENT_COMPLETE.md)
- **Interactive Showcase:** [component_generation/build/monument_asset_showcase.html](/Users/noisebox/Documents/3_Development/Repos/materialize/component_generation/build/monument_asset_showcase.html)
- **PBR Technical Specs:** [component_generation/INTEGRATION_ARCHITECTURE.md](/Users/noisebox/Documents/3_Development/Repos/materialize/component_generation/INTEGRATION_ARCHITECTURE.md)
- **JUCE Graphics API:** https://docs.juce.com/master/classGraphics.html

---

**Document Status:** ✅ Ready for Implementation
**Estimated Total Time:** 7-12 hours for full integration
**Priority:** High (visual impact, matches brutalist aesthetic)